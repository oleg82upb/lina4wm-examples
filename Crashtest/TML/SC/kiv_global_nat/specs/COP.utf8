enrich 	CS,
		cindex,
		input with 

	functions
		INVOP : Proc × IJ → input × CS × CS → bool;
		COP : Proc × CJ → CS × CS → bool;
		RETOP : Proc × RJ → CS × CS × nat → bool;
	predicates
		CSInit : CS;

	variables
		invop : input × CS × CS → bool;
		cop : CS × CS → bool;
		retop : CS × CS × nat → bool;
		glb, glb' : ref;
		x, x' : ref;
		y, y' : ref;
		lx1, lx1' : ref;
		ly1, ly1' : ref;
		lx2, lx2' : ref;
		ly2, ly2' : ref;
		return : nat;
	axioms
	CSInit : 
	⊦ CSInit(mkcs(glb, x, y, lx1, ly1, lx2, ly2, pcf, mem, reff1, natf2, natf3, natf4, natf5, reff6, natf7, reff8, natf9, reff10, natf11, reff12, natf13, natf14, natf15, natf16, reff17, natf18, natf19, reff20, natf21, natf22, natf23, natf24, reff25, natf26, natf27, natf28, natf29, natf30, natf31, natf32, reff33)) ↔ ( glb = ⌜0⌝ ∧ x = ⌜0⌝ ∧ y = ⌜0⌝ ∧ lx1 = ⌜0⌝ ∧ ly1 = ⌜0⌝ ∧ lx2 = ⌜0⌝ ∧ ly2 = ⌜0⌝ ∧ pcf = (λ p. N)  ∧ reff1 = (λ p. ⌜0⌝) ∧ natf2 = (λ p. 0) ∧ natf3 = (λ p. 0) ∧ natf4 = (λ p. 0) ∧ natf5 = (λ p. 0) ∧ reff6 = (λ p. ⌜0⌝) ∧ natf7 = (λ p. 0) ∧ reff8 = (λ p. ⌜0⌝) ∧ natf9 = (λ p. 0) ∧ reff10 = (λ p. ⌜0⌝) ∧ natf11 = (λ p. 0) ∧ reff12 = (λ p. ⌜0⌝) ∧ natf13 = (λ p. 0) ∧ natf14 = (λ p. 0) ∧ natf15 = (λ p. 0) ∧ natf16 = (λ p. 0) ∧ reff17 = (λ p. ⌜0⌝) ∧ natf18 = (λ p. 0) ∧ natf19 = (λ p. 0) ∧ reff20 = (λ p. ⌜0⌝) ∧ natf21 = (λ p. 0) ∧ natf22 = (λ p. 0) ∧ natf23 = (λ p. 0) ∧ natf24 = (λ p. 0) ∧ reff25 = (λ p. ⌜0⌝) ∧ natf26 = (λ p. 0) ∧ natf27 = (λ p. 0) ∧ natf28 = (λ p. 0) ∧ natf29 = (λ p. 0) ∧ natf30 = (λ p. 0) ∧ natf31 = (λ p. 0) ∧ natf32 = (λ p. 0) ∧ reff33 = (λ p. ⌜0⌝));
	used for : s, ls;

;; 	proc11 reflects function @proc11
	proc11ini :
	⊦ INVOP(p, proc11ini)(inp, cs, cs') ↔ cs .pc(p) = N ∧ cs' = cs .pc:= cs.pc(p ; A00) ; 
	used for : s, ls;

;; 	proc21 reflects function @proc21
	proc21ini :
	⊦ INVOP(p, proc21ini)(inp, cs, cs') ↔ cs .pc(p) = N ∧ cs' = cs .pc:= cs.pc(p ; B00) ; 
	used for : s, ls;

;; 	proc12 reflects function @proc12
	proc12ini :
	⊦ INVOP(p, proc12ini)(inp, cs, cs') ↔ cs .pc(p) = N ∧ cs' = cs .pc:= cs.pc(p ; C00) ; 
	used for : s, ls;

;; 	proc22 reflects function @proc22
	proc22ini :
	⊦ INVOP(p, proc22ini)(inp, cs, cs') ↔ cs .pc(p) = N ∧ cs' = cs .pc:= cs.pc(p ; D00) ; 
	used for : s, ls;

;; 	proc13 reflects function @proc13
	proc13ini :
	⊦ INVOP(p, proc13ini)(inp, cs, cs') ↔ cs .pc(p) = N ∧ cs' = cs .pc:= cs.pc(p ; E00) ; 
	used for : s, ls;

;; 	proc23 reflects function @proc23
	proc23ini :
	⊦ INVOP(p, proc23ini)(inp, cs, cs') ↔ cs .pc(p) = N ∧ cs' = cs .pc:= cs.pc(p ; F00) ; 
	used for : s, ls;

;; 	proc33 reflects function @proc33
	proc33ini :
	⊦ INVOP(p, proc33ini)(inp, cs, cs') ↔ cs .pc(p) = N ∧ cs' = cs .pc:= cs.pc(p ; G00) ; 
	used for : s, ls;

;; 	proc43 reflects function @proc43
	proc43ini :
	⊦ INVOP(p, proc43ini)(inp, cs, cs') ↔ cs .pc(p) = N ∧ cs' = cs .pc:= cs.pc(p ; H00) ; 
	used for : s, ls;

;; 	main reflects function @main
	mainini :
	⊦ INVOP(p, mainini)(inp, cs, cs') ↔ cs .pc(p) = N ∧ natref?(inp) ∧ cs' = cs .pc:= cs.pc(p ; I0) .argv:= cs.argv(p ; inp .ref1).argc:= cs.argc(p ; inp .nat1); 
	used for : s, ls;

;;	%0 = load i32** @glb, align 4, !tbaa !0
	proc111 :
	⊦ COP(p, proc111)(cs, cs') ↔ cs .pc(p) = A00 ∧ cs' = cs .pc:= cs.pc(p ; A01) .v0:= cs.v0(p ; cs.mem[cs .glb .v]);
	used for : s, ls;

;;	br label %do.body
	proc112 :
	⊦ COP(p, proc112)(cs, cs') ↔ cs .pc(p) = A01 ∧ cs' = cs .pc:= cs.pc(p ; A02);
	used for : s, ls;

;;	%1 = load i32* %0, align 4, !tbaa !3
	proc113 :
	⊦ COP(p, proc113)(cs, cs') ↔ cs .pc(p) = A02 ∧ cs' = cs .pc:= cs.pc(p ; A03) .v1:= cs.v1(p ; cs.mem[cs .v0(p) .v] .v);
	used for : s, ls;

;;	%and = and i32 %1, 1
	NEEDS ATTENTION !
	proc114 :
	⊦ COP(p, proc114)(cs, cs') ↔ cs .pc(p) = A03 ∧ cs' = cs .pc:= cs.pc(p ; A04);
	used for : s, ls;

;;	%tobool = icmp eq i32 %and, 0
	proc115 :
	⊦ COP(p, proc115)(cs, cs') ↔ cs .pc(p) = A04 ∧ (cs .and(p) = 0
	 ⊃ cs' = cs .pc:= cs.pc(p; A05) .tobool:= cs.tobool(p ; 1) ; cs' = cs .pc:= cs.pc(p; A05) .tobool:= cs.tobool(p ; 0));
	used for : s, ls;

;;	br %tobool, label %if.then, label %do.body
	proc116 :
	⊦ COP(p, proc116)(cs, cs') ↔ cs .pc(p) = A05 ∧ cs' = cs .pc:= cs.pc(p ; A06) ∧ cs .tobool(p) = 1;
	used for : s, ls;

;;	br %tobool, label %if.then, label %do.body
	proc117 :
	⊦ COP(p, proc117)(cs, cs') ↔ cs .pc(p) = A05 ∧ cs' = cs .pc:= cs.pc(p ; A02) ∧ cs .tobool(p) = 0;
	used for : s, ls;

;;	%add = add i32 %1, 1
	proc118 :
	⊦ COP(p, proc118)(cs, cs') ↔ cs .pc(p) = A06 ∧ cs' = cs .pc:= cs.pc(p ; A07) .add:= cs.add(p ; cs .v1(p) + 1);
	used for : s, ls;

;;	%2 = cmpxchg i32* %0, i32 %1, i32 %add seq_cst
	proc119 :
	⊦ COP(p, proc119)(cs, cs') ↔ cs .pc(p) = A07 ∧ ( cs.mem[cs .v0(p) .v] = ⌜ cs .v1(p)⌝ ⊃ (cs' = cs .pc:= cs.pc(p; A08) .v2:= cs.v2(p ; ⌜1⌝) .mem:= cs.mem[cs .v0(p) .v, ⌜ cs .add(p)⌝]) ; (cs' = cs .pc:= cs.pc(p; A08) .v2:= cs.v2(p ; ⌜0⌝)));
	used for : s, ls;

;;	%3 = icmp eq i32 %2, %1
	proc1110 :
	⊦ COP(p, proc1110)(cs, cs') ↔ cs .pc(p) = A08 ∧ (cs .v2(p) = ⌜cs .v1(p)⌝ ⊃ cs' = cs .pc:= cs.pc(p; A09) .v3:= cs.v3(p ; 1) ; cs' = cs .pc:= cs.pc(p; A09) .v3:= cs.v3(p ; 0));
	used for : s, ls;

;;	br %3, label %if.end4, label %return
	proc1111 :
	⊦ COP(p, proc1111)(cs, cs') ↔ cs .pc(p) = A09 ∧ cs' = cs .pc:= cs.pc(p ; A10) ∧ cs .v3(p) = 1;
	used for : s, ls;

;;	br %3, label %if.end4, label %return
	proc1112 :
	⊦ COP(p, proc1112)(cs, cs') ↔ cs .pc(p) = A09 ∧ cs' = cs .pc:= cs.pc(p ; A28) .retval_0:= cs.retval_0(p ; (0 - 1)) ∧ cs .v3(p) = 0;
	used for : s, ls;

;;	%4 = load i32** @x, align 4, !tbaa !0
	proc1113 :
	⊦ COP(p, proc1113)(cs, cs') ↔ cs .pc(p) = A10 ∧ cs' = cs .pc:= cs.pc(p ; A11) .v4:= cs.v4(p ; cs.mem[cs .x .v]);
	used for : s, ls;

;;	%retval.0 = phi i32 [, %if.then][, %if.end4][, %if.end6][, %if.then9]
	proc1114 :
	⊦ COP(p, proc1114)(cs, cs') ↔ cs .pc(p) = A28 ∧ cs' = cs .pc:= cs.pc(p ; A29);
	used for : s, ls;

;;	store i32 1, i32* %4, align 4, !tbaa !3
	proc1115 :
	⊦ COP(p, proc1115)(cs, cs') ↔ cs .pc(p) = A11 ∧ cs' = cs .pc:= cs.pc(p ; A12);
	used for : s, ls;

;;	%5 = load i32** @y, align 4, !tbaa !0
	proc1117 :
	⊦ COP(p, proc1117)(cs, cs') ↔ cs .pc(p) = A12 ∧ cs' = cs .pc:= cs.pc(p ; A13) .v5:= cs.v5(p ; cs.mem[cs .y .v]);
	used for : s, ls;

;;	%6 = load i32* %5, align 4, !tbaa !3
	proc1118 :
	⊦ COP(p, proc1118)(cs, cs') ↔ cs .pc(p) = A13 ∧ cs' = cs .pc:= cs.pc(p ; A14) .v6:= cs.v6(p ; cs.mem[cs .v5(p) .v] .v);
	used for : s, ls;

;;	%7 = load i32** @glb, align 4, !tbaa !0
	proc1119 :
	⊦ COP(p, proc1119)(cs, cs') ↔ cs .pc(p) = A14 ∧ cs' = cs .pc:= cs.pc(p ; A15) .v7:= cs.v7(p ; cs.mem[cs .glb .v]);
	used for : s, ls;

;;	%8 = load i32* %7, align 4, !tbaa !3
	proc1120 :
	⊦ COP(p, proc1120)(cs, cs') ↔ cs .pc(p) = A15 ∧ cs' = cs .pc:= cs.pc(p ; A16) .v8:= cs.v8(p ; cs.mem[cs .v7(p) .v] .v);
	used for : s, ls;

;;	%cmp = icmp eq i32 %8, %add
	proc1121 :
	⊦ COP(p, proc1121)(cs, cs') ↔ cs .pc(p) = A16 ∧ (cs .v8(p) = cs .add(p)
	 ⊃ cs' = cs .pc:= cs.pc(p; A17) .cmp:= cs.cmp(p ; 1) ; cs' = cs .pc:= cs.pc(p; A17) .cmp:= cs.cmp(p ; 0));
	used for : s, ls;

;;	br %cmp, label %if.end6, label %return
	proc1122 :
	⊦ COP(p, proc1122)(cs, cs') ↔ cs .pc(p) = A17 ∧ cs' = cs .pc:= cs.pc(p ; A18) ∧ cs .cmp(p) = 1;
	used for : s, ls;

;;	br %cmp, label %if.end6, label %return
	proc1123 :
	⊦ COP(p, proc1123)(cs, cs') ↔ cs .pc(p) = A17 ∧ cs' = cs .pc:= cs.pc(p ; A28) .retval_0:= cs.retval_0(p ; (0 - 1)) ∧ cs .cmp(p) = 0;
	used for : s, ls;

;;	store i32 %6, i32* @ly1, align 4, !tbaa !3
	proc1124 :
	⊦ COP(p, proc1124)(cs, cs') ↔ cs .pc(p) = A18 ∧ cs' = cs .pc:= cs.pc(p ; A19);
	used for : s, ls;

;;	%and7 = and i32 %add, 1
	NEEDS ATTENTION !
	proc1125 :
	⊦ COP(p, proc1125)(cs, cs') ↔ cs .pc(p) = A19 ∧ cs' = cs .pc:= cs.pc(p ; A20);
	used for : s, ls;

;;	%tobool8 = icmp eq i32 %and7, 0
	proc1126 :
	⊦ COP(p, proc1126)(cs, cs') ↔ cs .pc(p) = A20 ∧ (cs .and7(p) = 0
	 ⊃ cs' = cs .pc:= cs.pc(p; A21) .tobool8:= cs.tobool8(p ; 1) ; cs' = cs .pc:= cs.pc(p; A21) .tobool8:= cs.tobool8(p ; 0));
	used for : s, ls;

;;	br %tobool8, label %return, label %if.then9
	proc1127 :
	⊦ COP(p, proc1127)(cs, cs') ↔ cs .pc(p) = A21 ∧ cs' = cs .pc:= cs.pc(p ; A28) .retval_0:= cs.retval_0(p ; 1) ∧ cs .tobool8(p) = 1;
	used for : s, ls;

;;	br %tobool8, label %return, label %if.then9
	proc1128 :
	⊦ COP(p, proc1128)(cs, cs') ↔ cs .pc(p) = A21 ∧ cs' = cs .pc:= cs.pc(p ; A22) ∧ cs .tobool8(p) = 0;
	used for : s, ls;

;;	fence seq_cst
	proc1129 :
	⊦ COP(p, proc1129)(cs, cs') ↔ cs .pc(p) = A22 ∧ cs' = cs .pc:= cs.pc(p ; A23);
	used for : s, ls;

;;	%9 = load i32** @glb, align 4, !tbaa !0
	proc1130 :
	⊦ COP(p, proc1130)(cs, cs') ↔ cs .pc(p) = A23 ∧ cs' = cs .pc:= cs.pc(p ; A24) .v9:= cs.v9(p ; cs.mem[cs .glb .v]);
	used for : s, ls;

;;	%10 = load i32* %9, align 4, !tbaa !3
	proc1131 :
	⊦ COP(p, proc1131)(cs, cs') ↔ cs .pc(p) = A24 ∧ cs' = cs .pc:= cs.pc(p ; A25) .10:= cs.10(p ; cs.mem[cs .v9(p) .v] .v);
	used for : s, ls;

;;	%inc10 = add i32 %10, 1
	proc1132 :
	⊦ COP(p, proc1132)(cs, cs') ↔ cs .pc(p) = A25 ∧ cs' = cs .pc:= cs.pc(p ; A26) .inc10:= cs.inc10(p ; cs .10(p) + 1);
	used for : s, ls;

;;	store i32 %inc10, i32* %9, align 4, !tbaa !3
	proc1133 :
	⊦ COP(p, proc1133)(cs, cs') ↔ cs .pc(p) = A26 ∧ cs' = cs .pc:= cs.pc(p ; A27);
	used for : s, ls;

;;	br label %return
	proc1134 :
	⊦ COP(p, proc1134)(cs, cs') ↔ cs .pc(p) = A27 ∧ cs' = cs .pc:= cs.pc(p ; A28) .retval_0:= cs.retval_0(p ; 1);
	used for : s, ls;

;;	%0 = load i32** @glb, align 4, !tbaa !0
	proc211 :
	⊦ COP(p, proc211)(cs, cs') ↔ cs .pc(p) = B00 ∧ cs' = cs .pc:= cs.pc(p ; B01) .v0:= cs.v0(p ; cs.mem[cs .glb .v]);
	used for : s, ls;

;;	br label %do.body
	proc212 :
	⊦ COP(p, proc212)(cs, cs') ↔ cs .pc(p) = B01 ∧ cs' = cs .pc:= cs.pc(p ; B02);
	used for : s, ls;

;;	%1 = load i32* %0, align 4, !tbaa !3
	proc213 :
	⊦ COP(p, proc213)(cs, cs') ↔ cs .pc(p) = B02 ∧ cs' = cs .pc:= cs.pc(p ; B03) .v1:= cs.v1(p ; cs.mem[cs .v0(p) .v] .v);
	used for : s, ls;

;;	%and = and i32 %1, 1
	NEEDS ATTENTION !
	proc214 :
	⊦ COP(p, proc214)(cs, cs') ↔ cs .pc(p) = B03 ∧ cs' = cs .pc:= cs.pc(p ; B04);
	used for : s, ls;

;;	%tobool = icmp eq i32 %and, 0
	proc215 :
	⊦ COP(p, proc215)(cs, cs') ↔ cs .pc(p) = B04 ∧ (cs .and(p) = 0
	 ⊃ cs' = cs .pc:= cs.pc(p; B05) .tobool:= cs.tobool(p ; 1) ; cs' = cs .pc:= cs.pc(p; B05) .tobool:= cs.tobool(p ; 0));
	used for : s, ls;

;;	br %tobool, label %if.then, label %do.body
	proc216 :
	⊦ COP(p, proc216)(cs, cs') ↔ cs .pc(p) = B05 ∧ cs' = cs .pc:= cs.pc(p ; B06) ∧ cs .tobool(p) = 1;
	used for : s, ls;

;;	br %tobool, label %if.then, label %do.body
	proc217 :
	⊦ COP(p, proc217)(cs, cs') ↔ cs .pc(p) = B05 ∧ cs' = cs .pc:= cs.pc(p ; B02) ∧ cs .tobool(p) = 0;
	used for : s, ls;

;;	%add = add i32 %1, 1
	proc218 :
	⊦ COP(p, proc218)(cs, cs') ↔ cs .pc(p) = B06 ∧ cs' = cs .pc:= cs.pc(p ; B07) .add:= cs.add(p ; cs .v1(p) + 1);
	used for : s, ls;

;;	%2 = cmpxchg i32* %0, i32 %1, i32 %add seq_cst
	proc219 :
	⊦ COP(p, proc219)(cs, cs') ↔ cs .pc(p) = B07 ∧ ( cs.mem[cs .v0(p) .v] = ⌜ cs .v1(p)⌝ ⊃ (cs' = cs .pc:= cs.pc(p; B08) .v2:= cs.v2(p ; ⌜1⌝) .mem:= cs.mem[cs .v0(p) .v, ⌜ cs .add(p)⌝]) ; (cs' = cs .pc:= cs.pc(p; B08) .v2:= cs.v2(p ; ⌜0⌝)));
	used for : s, ls;

;;	%3 = icmp eq i32 %2, %1
	proc2110 :
	⊦ COP(p, proc2110)(cs, cs') ↔ cs .pc(p) = B08 ∧ (cs .v2(p) = ⌜cs .v1(p)⌝ ⊃ cs' = cs .pc:= cs.pc(p; B09) .v3:= cs.v3(p ; 1) ; cs' = cs .pc:= cs.pc(p; B09) .v3:= cs.v3(p ; 0));
	used for : s, ls;

;;	br %3, label %if.end4, label %return
	proc2111 :
	⊦ COP(p, proc2111)(cs, cs') ↔ cs .pc(p) = B09 ∧ cs' = cs .pc:= cs.pc(p ; B10) ∧ cs .v3(p) = 1;
	used for : s, ls;

;;	br %3, label %if.end4, label %return
	proc2112 :
	⊦ COP(p, proc2112)(cs, cs') ↔ cs .pc(p) = B09 ∧ cs' = cs .pc:= cs.pc(p ; B28) .retval_0:= cs.retval_0(p ; (0 - 1)) ∧ cs .v3(p) = 0;
	used for : s, ls;

;;	%4 = load i32** @y, align 4, !tbaa !0
	proc2113 :
	⊦ COP(p, proc2113)(cs, cs') ↔ cs .pc(p) = B10 ∧ cs' = cs .pc:= cs.pc(p ; B11) .v4:= cs.v4(p ; cs.mem[cs .y .v]);
	used for : s, ls;

;;	%retval.0 = phi i32 [, %if.then][, %if.end4][, %if.end6][, %if.then9]
	proc2114 :
	⊦ COP(p, proc2114)(cs, cs') ↔ cs .pc(p) = B28 ∧ cs' = cs .pc:= cs.pc(p ; B29);
	used for : s, ls;

;;	store i32 1, i32* %4, align 4, !tbaa !3
	proc2115 :
	⊦ COP(p, proc2115)(cs, cs') ↔ cs .pc(p) = B11 ∧ cs' = cs .pc:= cs.pc(p ; B12);
	used for : s, ls;

;;	%5 = load i32** @x, align 4, !tbaa !0
	proc2117 :
	⊦ COP(p, proc2117)(cs, cs') ↔ cs .pc(p) = B12 ∧ cs' = cs .pc:= cs.pc(p ; B13) .v5:= cs.v5(p ; cs.mem[cs .x .v]);
	used for : s, ls;

;;	%6 = load i32* %5, align 4, !tbaa !3
	proc2118 :
	⊦ COP(p, proc2118)(cs, cs') ↔ cs .pc(p) = B13 ∧ cs' = cs .pc:= cs.pc(p ; B14) .v6:= cs.v6(p ; cs.mem[cs .v5(p) .v] .v);
	used for : s, ls;

;;	%7 = load i32** @glb, align 4, !tbaa !0
	proc2119 :
	⊦ COP(p, proc2119)(cs, cs') ↔ cs .pc(p) = B14 ∧ cs' = cs .pc:= cs.pc(p ; B15) .v7:= cs.v7(p ; cs.mem[cs .glb .v]);
	used for : s, ls;

;;	%8 = load i32* %7, align 4, !tbaa !3
	proc2120 :
	⊦ COP(p, proc2120)(cs, cs') ↔ cs .pc(p) = B15 ∧ cs' = cs .pc:= cs.pc(p ; B16) .v8:= cs.v8(p ; cs.mem[cs .v7(p) .v] .v);
	used for : s, ls;

;;	%cmp = icmp eq i32 %8, %add
	proc2121 :
	⊦ COP(p, proc2121)(cs, cs') ↔ cs .pc(p) = B16 ∧ (cs .v8(p) = cs .add(p)
	 ⊃ cs' = cs .pc:= cs.pc(p; B17) .cmp:= cs.cmp(p ; 1) ; cs' = cs .pc:= cs.pc(p; B17) .cmp:= cs.cmp(p ; 0));
	used for : s, ls;

;;	br %cmp, label %if.end6, label %return
	proc2122 :
	⊦ COP(p, proc2122)(cs, cs') ↔ cs .pc(p) = B17 ∧ cs' = cs .pc:= cs.pc(p ; B18) ∧ cs .cmp(p) = 1;
	used for : s, ls;

;;	br %cmp, label %if.end6, label %return
	proc2123 :
	⊦ COP(p, proc2123)(cs, cs') ↔ cs .pc(p) = B17 ∧ cs' = cs .pc:= cs.pc(p ; B28) .retval_0:= cs.retval_0(p ; (0 - 1)) ∧ cs .cmp(p) = 0;
	used for : s, ls;

;;	store i32 %6, i32* @lx2, align 4, !tbaa !3
	proc2124 :
	⊦ COP(p, proc2124)(cs, cs') ↔ cs .pc(p) = B18 ∧ cs' = cs .pc:= cs.pc(p ; B19);
	used for : s, ls;

;;	%and7 = and i32 %add, 1
	NEEDS ATTENTION !
	proc2125 :
	⊦ COP(p, proc2125)(cs, cs') ↔ cs .pc(p) = B19 ∧ cs' = cs .pc:= cs.pc(p ; B20);
	used for : s, ls;

;;	%tobool8 = icmp eq i32 %and7, 0
	proc2126 :
	⊦ COP(p, proc2126)(cs, cs') ↔ cs .pc(p) = B20 ∧ (cs .and7(p) = 0
	 ⊃ cs' = cs .pc:= cs.pc(p; B21) .tobool8:= cs.tobool8(p ; 1) ; cs' = cs .pc:= cs.pc(p; B21) .tobool8:= cs.tobool8(p ; 0));
	used for : s, ls;

;;	br %tobool8, label %return, label %if.then9
	proc2127 :
	⊦ COP(p, proc2127)(cs, cs') ↔ cs .pc(p) = B21 ∧ cs' = cs .pc:= cs.pc(p ; B28) .retval_0:= cs.retval_0(p ; 1) ∧ cs .tobool8(p) = 1;
	used for : s, ls;

;;	br %tobool8, label %return, label %if.then9
	proc2128 :
	⊦ COP(p, proc2128)(cs, cs') ↔ cs .pc(p) = B21 ∧ cs' = cs .pc:= cs.pc(p ; B22) ∧ cs .tobool8(p) = 0;
	used for : s, ls;

;;	fence seq_cst
	proc2129 :
	⊦ COP(p, proc2129)(cs, cs') ↔ cs .pc(p) = B22 ∧ cs' = cs .pc:= cs.pc(p ; B23);
	used for : s, ls;

;;	%9 = load i32** @glb, align 4, !tbaa !0
	proc2130 :
	⊦ COP(p, proc2130)(cs, cs') ↔ cs .pc(p) = B23 ∧ cs' = cs .pc:= cs.pc(p ; B24) .v9:= cs.v9(p ; cs.mem[cs .glb .v]);
	used for : s, ls;

;;	%10 = load i32* %9, align 4, !tbaa !3
	proc2131 :
	⊦ COP(p, proc2131)(cs, cs') ↔ cs .pc(p) = B24 ∧ cs' = cs .pc:= cs.pc(p ; B25) .10:= cs.10(p ; cs.mem[cs .v9(p) .v] .v);
	used for : s, ls;

;;	%inc10 = add i32 %10, 1
	proc2132 :
	⊦ COP(p, proc2132)(cs, cs') ↔ cs .pc(p) = B25 ∧ cs' = cs .pc:= cs.pc(p ; B26) .inc10:= cs.inc10(p ; cs .10(p) + 1);
	used for : s, ls;

;;	store i32 %inc10, i32* %9, align 4, !tbaa !3
	proc2133 :
	⊦ COP(p, proc2133)(cs, cs') ↔ cs .pc(p) = B26 ∧ cs' = cs .pc:= cs.pc(p ; B27);
	used for : s, ls;

;;	br label %return
	proc2134 :
	⊦ COP(p, proc2134)(cs, cs') ↔ cs .pc(p) = B27 ∧ cs' = cs .pc:= cs.pc(p ; B28) .retval_0:= cs.retval_0(p ; 1);
	used for : s, ls;

;;	%0 = load i32** @glb, align 4, !tbaa !0
	proc121 :
	⊦ COP(p, proc121)(cs, cs') ↔ cs .pc(p) = C00 ∧ cs' = cs .pc:= cs.pc(p ; C01) .v0:= cs.v0(p ; cs.mem[cs .glb .v]);
	used for : s, ls;

;;	br label %do.body
	proc122 :
	⊦ COP(p, proc122)(cs, cs') ↔ cs .pc(p) = C01 ∧ cs' = cs .pc:= cs.pc(p ; C02);
	used for : s, ls;

;;	%1 = load i32* %0, align 4, !tbaa !3
	proc123 :
	⊦ COP(p, proc123)(cs, cs') ↔ cs .pc(p) = C02 ∧ cs' = cs .pc:= cs.pc(p ; C03) .v1:= cs.v1(p ; cs.mem[cs .v0(p) .v] .v);
	used for : s, ls;

;;	%and = and i32 %1, 1
	NEEDS ATTENTION !
	proc124 :
	⊦ COP(p, proc124)(cs, cs') ↔ cs .pc(p) = C03 ∧ cs' = cs .pc:= cs.pc(p ; C04);
	used for : s, ls;

;;	%tobool = icmp eq i32 %and, 0
	proc125 :
	⊦ COP(p, proc125)(cs, cs') ↔ cs .pc(p) = C04 ∧ (cs .and(p) = 0
	 ⊃ cs' = cs .pc:= cs.pc(p; C05) .tobool:= cs.tobool(p ; 1) ; cs' = cs .pc:= cs.pc(p; C05) .tobool:= cs.tobool(p ; 0));
	used for : s, ls;

;;	br %tobool, label %if.then, label %do.body
	proc126 :
	⊦ COP(p, proc126)(cs, cs') ↔ cs .pc(p) = C05 ∧ cs' = cs .pc:= cs.pc(p ; C06) ∧ cs .tobool(p) = 1;
	used for : s, ls;

;;	br %tobool, label %if.then, label %do.body
	proc127 :
	⊦ COP(p, proc127)(cs, cs') ↔ cs .pc(p) = C05 ∧ cs' = cs .pc:= cs.pc(p ; C02) ∧ cs .tobool(p) = 0;
	used for : s, ls;

;;	%add = add i32 %1, 1
	proc128 :
	⊦ COP(p, proc128)(cs, cs') ↔ cs .pc(p) = C06 ∧ cs' = cs .pc:= cs.pc(p ; C07) .add:= cs.add(p ; cs .v1(p) + 1);
	used for : s, ls;

;;	%2 = cmpxchg i32* %0, i32 %1, i32 %add seq_cst
	proc129 :
	⊦ COP(p, proc129)(cs, cs') ↔ cs .pc(p) = C07 ∧ ( cs.mem[cs .v0(p) .v] = ⌜ cs .v1(p)⌝ ⊃ (cs' = cs .pc:= cs.pc(p; C08) .v2:= cs.v2(p ; ⌜1⌝) .mem:= cs.mem[cs .v0(p) .v, ⌜ cs .add(p)⌝]) ; (cs' = cs .pc:= cs.pc(p; C08) .v2:= cs.v2(p ; ⌜0⌝)));
	used for : s, ls;

;;	%3 = icmp eq i32 %2, %1
	proc1210 :
	⊦ COP(p, proc1210)(cs, cs') ↔ cs .pc(p) = C08 ∧ (cs .v2(p) = ⌜cs .v1(p)⌝ ⊃ cs' = cs .pc:= cs.pc(p; C09) .v3:= cs.v3(p ; 1) ; cs' = cs .pc:= cs.pc(p; C09) .v3:= cs.v3(p ; 0));
	used for : s, ls;

;;	br %3, label %if.end4, label %return
	proc1211 :
	⊦ COP(p, proc1211)(cs, cs') ↔ cs .pc(p) = C09 ∧ cs' = cs .pc:= cs.pc(p ; C10) ∧ cs .v3(p) = 1;
	used for : s, ls;

;;	br %3, label %if.end4, label %return
	proc1212 :
	⊦ COP(p, proc1212)(cs, cs') ↔ cs .pc(p) = C09 ∧ cs' = cs .pc:= cs.pc(p ; C35) .retval_0:= cs.retval_0(p ; (0 - 1)) ∧ cs .v3(p) = 0;
	used for : s, ls;

;;	%4 = load i32** @x, align 4, !tbaa !0
	proc1213 :
	⊦ COP(p, proc1213)(cs, cs') ↔ cs .pc(p) = C10 ∧ cs' = cs .pc:= cs.pc(p ; C11) .v4:= cs.v4(p ; cs.mem[cs .x .v]);
	used for : s, ls;

;;	%retval.0 = phi i32 [, %if.then][, %if.end4][, %if.end6][, %if.end9][, %if.then12]
	proc1214 :
	⊦ COP(p, proc1214)(cs, cs') ↔ cs .pc(p) = C35 ∧ cs' = cs .pc:= cs.pc(p ; C36);
	used for : s, ls;

;;	store i32 1, i32* %4, align 4, !tbaa !3
	proc1215 :
	⊦ COP(p, proc1215)(cs, cs') ↔ cs .pc(p) = C11 ∧ cs' = cs .pc:= cs.pc(p ; C12);
	used for : s, ls;

;;	%5 = load i32** @x, align 4, !tbaa !0
	proc1217 :
	⊦ COP(p, proc1217)(cs, cs') ↔ cs .pc(p) = C12 ∧ cs' = cs .pc:= cs.pc(p ; C13) .v5:= cs.v5(p ; cs.mem[cs .x .v]);
	used for : s, ls;

;;	%6 = load i32* %5, align 4, !tbaa !3
	proc1218 :
	⊦ COP(p, proc1218)(cs, cs') ↔ cs .pc(p) = C13 ∧ cs' = cs .pc:= cs.pc(p ; C14) .v6:= cs.v6(p ; cs.mem[cs .v5(p) .v] .v);
	used for : s, ls;

;;	%7 = load i32** @glb, align 4, !tbaa !0
	proc1219 :
	⊦ COP(p, proc1219)(cs, cs') ↔ cs .pc(p) = C14 ∧ cs' = cs .pc:= cs.pc(p ; C15) .v7:= cs.v7(p ; cs.mem[cs .glb .v]);
	used for : s, ls;

;;	%8 = load i32* %7, align 4, !tbaa !3
	proc1220 :
	⊦ COP(p, proc1220)(cs, cs') ↔ cs .pc(p) = C15 ∧ cs' = cs .pc:= cs.pc(p ; C16) .v8:= cs.v8(p ; cs.mem[cs .v7(p) .v] .v);
	used for : s, ls;

;;	%cmp = icmp eq i32 %8, %add
	proc1221 :
	⊦ COP(p, proc1221)(cs, cs') ↔ cs .pc(p) = C16 ∧ (cs .v8(p) = cs .add(p)
	 ⊃ cs' = cs .pc:= cs.pc(p; C17) .cmp:= cs.cmp(p ; 1) ; cs' = cs .pc:= cs.pc(p; C17) .cmp:= cs.cmp(p ; 0));
	used for : s, ls;

;;	br %cmp, label %if.end6, label %return
	proc1222 :
	⊦ COP(p, proc1222)(cs, cs') ↔ cs .pc(p) = C17 ∧ cs' = cs .pc:= cs.pc(p ; C18) ∧ cs .cmp(p) = 1;
	used for : s, ls;

;;	br %cmp, label %if.end6, label %return
	proc1223 :
	⊦ COP(p, proc1223)(cs, cs') ↔ cs .pc(p) = C17 ∧ cs' = cs .pc:= cs.pc(p ; C35) .retval_0:= cs.retval_0(p ; (0 - 1)) ∧ cs .cmp(p) = 0;
	used for : s, ls;

;;	store i32 %6, i32* @lx1, align 4, !tbaa !3
	proc1224 :
	⊦ COP(p, proc1224)(cs, cs') ↔ cs .pc(p) = C18 ∧ cs' = cs .pc:= cs.pc(p ; C19);
	used for : s, ls;

;;	%9 = load i32** @y, align 4, !tbaa !0
	proc1225 :
	⊦ COP(p, proc1225)(cs, cs') ↔ cs .pc(p) = C19 ∧ cs' = cs .pc:= cs.pc(p ; C20) .v9:= cs.v9(p ; cs.mem[cs .y .v]);
	used for : s, ls;

;;	%10 = load i32* %9, align 4, !tbaa !3
	proc1226 :
	⊦ COP(p, proc1226)(cs, cs') ↔ cs .pc(p) = C20 ∧ cs' = cs .pc:= cs.pc(p ; C21) .10:= cs.10(p ; cs.mem[cs .v9(p) .v] .v);
	used for : s, ls;

;;	%11 = load i32** @glb, align 4, !tbaa !0
	proc1227 :
	⊦ COP(p, proc1227)(cs, cs') ↔ cs .pc(p) = C21 ∧ cs' = cs .pc:= cs.pc(p ; C22) .11:= cs.11(p ; cs.mem[cs .glb .v]);
	used for : s, ls;

;;	%12 = load i32* %11, align 4, !tbaa !3
	proc1228 :
	⊦ COP(p, proc1228)(cs, cs') ↔ cs .pc(p) = C22 ∧ cs' = cs .pc:= cs.pc(p ; C23) .12:= cs.12(p ; cs.mem[cs .11(p) .v] .v);
	used for : s, ls;

;;	%cmp7 = icmp eq i32 %12, %add
	proc1229 :
	⊦ COP(p, proc1229)(cs, cs') ↔ cs .pc(p) = C23 ∧ (cs .12(p) = cs .add(p)
	 ⊃ cs' = cs .pc:= cs.pc(p; C24) .cmp7:= cs.cmp7(p ; 1) ; cs' = cs .pc:= cs.pc(p; C24) .cmp7:= cs.cmp7(p ; 0));
	used for : s, ls;

;;	br %cmp7, label %if.end9, label %return
	proc1230 :
	⊦ COP(p, proc1230)(cs, cs') ↔ cs .pc(p) = C24 ∧ cs' = cs .pc:= cs.pc(p ; C25) ∧ cs .cmp7(p) = 1;
	used for : s, ls;

;;	br %cmp7, label %if.end9, label %return
	proc1231 :
	⊦ COP(p, proc1231)(cs, cs') ↔ cs .pc(p) = C24 ∧ cs' = cs .pc:= cs.pc(p ; C35) .retval_0:= cs.retval_0(p ; (0 - 1)) ∧ cs .cmp7(p) = 0;
	used for : s, ls;

;;	store i32 %10, i32* @ly1, align 4, !tbaa !3
	proc1232 :
	⊦ COP(p, proc1232)(cs, cs') ↔ cs .pc(p) = C25 ∧ cs' = cs .pc:= cs.pc(p ; C26);
	used for : s, ls;

;;	%and10 = and i32 %add, 1
	NEEDS ATTENTION !
	proc1233 :
	⊦ COP(p, proc1233)(cs, cs') ↔ cs .pc(p) = C26 ∧ cs' = cs .pc:= cs.pc(p ; C27);
	used for : s, ls;

;;	%tobool11 = icmp eq i32 %and10, 0
	proc1234 :
	⊦ COP(p, proc1234)(cs, cs') ↔ cs .pc(p) = C27 ∧ (cs .and10(p) = 0
	 ⊃ cs' = cs .pc:= cs.pc(p; C28) .tobool11:= cs.tobool11(p ; 1) ; cs' = cs .pc:= cs.pc(p; C28) .tobool11:= cs.tobool11(p ; 0));
	used for : s, ls;

;;	br %tobool11, label %return, label %if.then12
	proc1235 :
	⊦ COP(p, proc1235)(cs, cs') ↔ cs .pc(p) = C28 ∧ cs' = cs .pc:= cs.pc(p ; C35) .retval_0:= cs.retval_0(p ; 1) ∧ cs .tobool11(p) = 1;
	used for : s, ls;

;;	br %tobool11, label %return, label %if.then12
	proc1236 :
	⊦ COP(p, proc1236)(cs, cs') ↔ cs .pc(p) = C28 ∧ cs' = cs .pc:= cs.pc(p ; C29) ∧ cs .tobool11(p) = 0;
	used for : s, ls;

;;	fence seq_cst
	proc1237 :
	⊦ COP(p, proc1237)(cs, cs') ↔ cs .pc(p) = C29 ∧ cs' = cs .pc:= cs.pc(p ; C30);
	used for : s, ls;

;;	%13 = load i32** @glb, align 4, !tbaa !0
	proc1238 :
	⊦ COP(p, proc1238)(cs, cs') ↔ cs .pc(p) = C30 ∧ cs' = cs .pc:= cs.pc(p ; C31) .13:= cs.13(p ; cs.mem[cs .glb .v]);
	used for : s, ls;

;;	%14 = load i32* %13, align 4, !tbaa !3
	proc1239 :
	⊦ COP(p, proc1239)(cs, cs') ↔ cs .pc(p) = C31 ∧ cs' = cs .pc:= cs.pc(p ; C32) .14:= cs.14(p ; cs.mem[cs .13(p) .v] .v);
	used for : s, ls;

;;	%inc13 = add i32 %14, 1
	proc1240 :
	⊦ COP(p, proc1240)(cs, cs') ↔ cs .pc(p) = C32 ∧ cs' = cs .pc:= cs.pc(p ; C33) .inc13:= cs.inc13(p ; cs .14(p) + 1);
	used for : s, ls;

;;	store i32 %inc13, i32* %13, align 4, !tbaa !3
	proc1241 :
	⊦ COP(p, proc1241)(cs, cs') ↔ cs .pc(p) = C33 ∧ cs' = cs .pc:= cs.pc(p ; C34);
	used for : s, ls;

;;	br label %return
	proc1242 :
	⊦ COP(p, proc1242)(cs, cs') ↔ cs .pc(p) = C34 ∧ cs' = cs .pc:= cs.pc(p ; C35) .retval_0:= cs.retval_0(p ; 1);
	used for : s, ls;

;;	%0 = load i32** @glb, align 4, !tbaa !0
	proc221 :
	⊦ COP(p, proc221)(cs, cs') ↔ cs .pc(p) = D00 ∧ cs' = cs .pc:= cs.pc(p ; D01) .v0:= cs.v0(p ; cs.mem[cs .glb .v]);
	used for : s, ls;

;;	br label %do.body
	proc222 :
	⊦ COP(p, proc222)(cs, cs') ↔ cs .pc(p) = D01 ∧ cs' = cs .pc:= cs.pc(p ; D02);
	used for : s, ls;

;;	%1 = load i32* %0, align 4, !tbaa !3
	proc223 :
	⊦ COP(p, proc223)(cs, cs') ↔ cs .pc(p) = D02 ∧ cs' = cs .pc:= cs.pc(p ; D03) .v1:= cs.v1(p ; cs.mem[cs .v0(p) .v] .v);
	used for : s, ls;

;;	%and = and i32 %1, 1
	NEEDS ATTENTION !
	proc224 :
	⊦ COP(p, proc224)(cs, cs') ↔ cs .pc(p) = D03 ∧ cs' = cs .pc:= cs.pc(p ; D04);
	used for : s, ls;

;;	%tobool = icmp eq i32 %and, 0
	proc225 :
	⊦ COP(p, proc225)(cs, cs') ↔ cs .pc(p) = D04 ∧ (cs .and(p) = 0
	 ⊃ cs' = cs .pc:= cs.pc(p; D05) .tobool:= cs.tobool(p ; 1) ; cs' = cs .pc:= cs.pc(p; D05) .tobool:= cs.tobool(p ; 0));
	used for : s, ls;

;;	br %tobool, label %if.then, label %do.body
	proc226 :
	⊦ COP(p, proc226)(cs, cs') ↔ cs .pc(p) = D05 ∧ cs' = cs .pc:= cs.pc(p ; D06) ∧ cs .tobool(p) = 1;
	used for : s, ls;

;;	br %tobool, label %if.then, label %do.body
	proc227 :
	⊦ COP(p, proc227)(cs, cs') ↔ cs .pc(p) = D05 ∧ cs' = cs .pc:= cs.pc(p ; D02) ∧ cs .tobool(p) = 0;
	used for : s, ls;

;;	%add = add i32 %1, 1
	proc228 :
	⊦ COP(p, proc228)(cs, cs') ↔ cs .pc(p) = D06 ∧ cs' = cs .pc:= cs.pc(p ; D07) .add:= cs.add(p ; cs .v1(p) + 1);
	used for : s, ls;

;;	%2 = cmpxchg i32* %0, i32 %1, i32 %add seq_cst
	proc229 :
	⊦ COP(p, proc229)(cs, cs') ↔ cs .pc(p) = D07 ∧ ( cs.mem[cs .v0(p) .v] = ⌜ cs .v1(p)⌝ ⊃ (cs' = cs .pc:= cs.pc(p; D08) .v2:= cs.v2(p ; ⌜1⌝) .mem:= cs.mem[cs .v0(p) .v, ⌜ cs .add(p)⌝]) ; (cs' = cs .pc:= cs.pc(p; D08) .v2:= cs.v2(p ; ⌜0⌝)));
	used for : s, ls;

;;	%3 = icmp eq i32 %2, %1
	proc2210 :
	⊦ COP(p, proc2210)(cs, cs') ↔ cs .pc(p) = D08 ∧ (cs .v2(p) = ⌜cs .v1(p)⌝ ⊃ cs' = cs .pc:= cs.pc(p; D09) .v3:= cs.v3(p ; 1) ; cs' = cs .pc:= cs.pc(p; D09) .v3:= cs.v3(p ; 0));
	used for : s, ls;

;;	br %3, label %if.end4, label %return
	proc2211 :
	⊦ COP(p, proc2211)(cs, cs') ↔ cs .pc(p) = D09 ∧ cs' = cs .pc:= cs.pc(p ; D10) ∧ cs .v3(p) = 1;
	used for : s, ls;

;;	br %3, label %if.end4, label %return
	proc2212 :
	⊦ COP(p, proc2212)(cs, cs') ↔ cs .pc(p) = D09 ∧ cs' = cs .pc:= cs.pc(p ; D35) .retval_0:= cs.retval_0(p ; (0 - 1)) ∧ cs .v3(p) = 0;
	used for : s, ls;

;;	%4 = load i32** @y, align 4, !tbaa !0
	proc2213 :
	⊦ COP(p, proc2213)(cs, cs') ↔ cs .pc(p) = D10 ∧ cs' = cs .pc:= cs.pc(p ; D11) .v4:= cs.v4(p ; cs.mem[cs .y .v]);
	used for : s, ls;

;;	%retval.0 = phi i32 [, %if.then][, %if.end4][, %if.end6][, %if.end9][, %if.then12]
	proc2214 :
	⊦ COP(p, proc2214)(cs, cs') ↔ cs .pc(p) = D35 ∧ cs' = cs .pc:= cs.pc(p ; D36);
	used for : s, ls;

;;	store i32 1, i32* %4, align 4, !tbaa !3
	proc2215 :
	⊦ COP(p, proc2215)(cs, cs') ↔ cs .pc(p) = D11 ∧ cs' = cs .pc:= cs.pc(p ; D12);
	used for : s, ls;

;;	%5 = load i32** @y, align 4, !tbaa !0
	proc2217 :
	⊦ COP(p, proc2217)(cs, cs') ↔ cs .pc(p) = D12 ∧ cs' = cs .pc:= cs.pc(p ; D13) .v5:= cs.v5(p ; cs.mem[cs .y .v]);
	used for : s, ls;

;;	%6 = load i32* %5, align 4, !tbaa !3
	proc2218 :
	⊦ COP(p, proc2218)(cs, cs') ↔ cs .pc(p) = D13 ∧ cs' = cs .pc:= cs.pc(p ; D14) .v6:= cs.v6(p ; cs.mem[cs .v5(p) .v] .v);
	used for : s, ls;

;;	%7 = load i32** @glb, align 4, !tbaa !0
	proc2219 :
	⊦ COP(p, proc2219)(cs, cs') ↔ cs .pc(p) = D14 ∧ cs' = cs .pc:= cs.pc(p ; D15) .v7:= cs.v7(p ; cs.mem[cs .glb .v]);
	used for : s, ls;

;;	%8 = load i32* %7, align 4, !tbaa !3
	proc2220 :
	⊦ COP(p, proc2220)(cs, cs') ↔ cs .pc(p) = D15 ∧ cs' = cs .pc:= cs.pc(p ; D16) .v8:= cs.v8(p ; cs.mem[cs .v7(p) .v] .v);
	used for : s, ls;

;;	%cmp = icmp eq i32 %8, %add
	proc2221 :
	⊦ COP(p, proc2221)(cs, cs') ↔ cs .pc(p) = D16 ∧ (cs .v8(p) = cs .add(p)
	 ⊃ cs' = cs .pc:= cs.pc(p; D17) .cmp:= cs.cmp(p ; 1) ; cs' = cs .pc:= cs.pc(p; D17) .cmp:= cs.cmp(p ; 0));
	used for : s, ls;

;;	br %cmp, label %if.end6, label %return
	proc2222 :
	⊦ COP(p, proc2222)(cs, cs') ↔ cs .pc(p) = D17 ∧ cs' = cs .pc:= cs.pc(p ; D18) ∧ cs .cmp(p) = 1;
	used for : s, ls;

;;	br %cmp, label %if.end6, label %return
	proc2223 :
	⊦ COP(p, proc2223)(cs, cs') ↔ cs .pc(p) = D17 ∧ cs' = cs .pc:= cs.pc(p ; D35) .retval_0:= cs.retval_0(p ; (0 - 1)) ∧ cs .cmp(p) = 0;
	used for : s, ls;

;;	store i32 %6, i32* @ly2, align 4, !tbaa !3
	proc2224 :
	⊦ COP(p, proc2224)(cs, cs') ↔ cs .pc(p) = D18 ∧ cs' = cs .pc:= cs.pc(p ; D19);
	used for : s, ls;

;;	%9 = load i32** @x, align 4, !tbaa !0
	proc2225 :
	⊦ COP(p, proc2225)(cs, cs') ↔ cs .pc(p) = D19 ∧ cs' = cs .pc:= cs.pc(p ; D20) .v9:= cs.v9(p ; cs.mem[cs .x .v]);
	used for : s, ls;

;;	%10 = load i32* %9, align 4, !tbaa !3
	proc2226 :
	⊦ COP(p, proc2226)(cs, cs') ↔ cs .pc(p) = D20 ∧ cs' = cs .pc:= cs.pc(p ; D21) .10:= cs.10(p ; cs.mem[cs .v9(p) .v] .v);
	used for : s, ls;

;;	%11 = load i32** @glb, align 4, !tbaa !0
	proc2227 :
	⊦ COP(p, proc2227)(cs, cs') ↔ cs .pc(p) = D21 ∧ cs' = cs .pc:= cs.pc(p ; D22) .11:= cs.11(p ; cs.mem[cs .glb .v]);
	used for : s, ls;

;;	%12 = load i32* %11, align 4, !tbaa !3
	proc2228 :
	⊦ COP(p, proc2228)(cs, cs') ↔ cs .pc(p) = D22 ∧ cs' = cs .pc:= cs.pc(p ; D23) .12:= cs.12(p ; cs.mem[cs .11(p) .v] .v);
	used for : s, ls;

;;	%cmp7 = icmp eq i32 %12, %add
	proc2229 :
	⊦ COP(p, proc2229)(cs, cs') ↔ cs .pc(p) = D23 ∧ (cs .12(p) = cs .add(p)
	 ⊃ cs' = cs .pc:= cs.pc(p; D24) .cmp7:= cs.cmp7(p ; 1) ; cs' = cs .pc:= cs.pc(p; D24) .cmp7:= cs.cmp7(p ; 0));
	used for : s, ls;

;;	br %cmp7, label %if.end9, label %return
	proc2230 :
	⊦ COP(p, proc2230)(cs, cs') ↔ cs .pc(p) = D24 ∧ cs' = cs .pc:= cs.pc(p ; D25) ∧ cs .cmp7(p) = 1;
	used for : s, ls;

;;	br %cmp7, label %if.end9, label %return
	proc2231 :
	⊦ COP(p, proc2231)(cs, cs') ↔ cs .pc(p) = D24 ∧ cs' = cs .pc:= cs.pc(p ; D35) .retval_0:= cs.retval_0(p ; (0 - 1)) ∧ cs .cmp7(p) = 0;
	used for : s, ls;

;;	store i32 %10, i32* @lx2, align 4, !tbaa !3
	proc2232 :
	⊦ COP(p, proc2232)(cs, cs') ↔ cs .pc(p) = D25 ∧ cs' = cs .pc:= cs.pc(p ; D26);
	used for : s, ls;

;;	%and10 = and i32 %add, 1
	NEEDS ATTENTION !
	proc2233 :
	⊦ COP(p, proc2233)(cs, cs') ↔ cs .pc(p) = D26 ∧ cs' = cs .pc:= cs.pc(p ; D27);
	used for : s, ls;

;;	%tobool11 = icmp eq i32 %and10, 0
	proc2234 :
	⊦ COP(p, proc2234)(cs, cs') ↔ cs .pc(p) = D27 ∧ (cs .and10(p) = 0
	 ⊃ cs' = cs .pc:= cs.pc(p; D28) .tobool11:= cs.tobool11(p ; 1) ; cs' = cs .pc:= cs.pc(p; D28) .tobool11:= cs.tobool11(p ; 0));
	used for : s, ls;

;;	br %tobool11, label %return, label %if.then12
	proc2235 :
	⊦ COP(p, proc2235)(cs, cs') ↔ cs .pc(p) = D28 ∧ cs' = cs .pc:= cs.pc(p ; D35) .retval_0:= cs.retval_0(p ; 1) ∧ cs .tobool11(p) = 1;
	used for : s, ls;

;;	br %tobool11, label %return, label %if.then12
	proc2236 :
	⊦ COP(p, proc2236)(cs, cs') ↔ cs .pc(p) = D28 ∧ cs' = cs .pc:= cs.pc(p ; D29) ∧ cs .tobool11(p) = 0;
	used for : s, ls;

;;	fence seq_cst
	proc2237 :
	⊦ COP(p, proc2237)(cs, cs') ↔ cs .pc(p) = D29 ∧ cs' = cs .pc:= cs.pc(p ; D30);
	used for : s, ls;

;;	%13 = load i32** @glb, align 4, !tbaa !0
	proc2238 :
	⊦ COP(p, proc2238)(cs, cs') ↔ cs .pc(p) = D30 ∧ cs' = cs .pc:= cs.pc(p ; D31) .13:= cs.13(p ; cs.mem[cs .glb .v]);
	used for : s, ls;

;;	%14 = load i32* %13, align 4, !tbaa !3
	proc2239 :
	⊦ COP(p, proc2239)(cs, cs') ↔ cs .pc(p) = D31 ∧ cs' = cs .pc:= cs.pc(p ; D32) .14:= cs.14(p ; cs.mem[cs .13(p) .v] .v);
	used for : s, ls;

;;	%inc13 = add i32 %14, 1
	proc2240 :
	⊦ COP(p, proc2240)(cs, cs') ↔ cs .pc(p) = D32 ∧ cs' = cs .pc:= cs.pc(p ; D33) .inc13:= cs.inc13(p ; cs .14(p) + 1);
	used for : s, ls;

;;	store i32 %inc13, i32* %13, align 4, !tbaa !3
	proc2241 :
	⊦ COP(p, proc2241)(cs, cs') ↔ cs .pc(p) = D33 ∧ cs' = cs .pc:= cs.pc(p ; D34);
	used for : s, ls;

;;	br label %return
	proc2242 :
	⊦ COP(p, proc2242)(cs, cs') ↔ cs .pc(p) = D34 ∧ cs' = cs .pc:= cs.pc(p ; D35) .retval_0:= cs.retval_0(p ; 1);
	used for : s, ls;

;;	%0 = load i32** @glb, align 4, !tbaa !0
	proc131 :
	⊦ COP(p, proc131)(cs, cs') ↔ cs .pc(p) = E00 ∧ cs' = cs .pc:= cs.pc(p ; E01) .v0:= cs.v0(p ; cs.mem[cs .glb .v]);
	used for : s, ls;

;;	br label %do.body
	proc132 :
	⊦ COP(p, proc132)(cs, cs') ↔ cs .pc(p) = E01 ∧ cs' = cs .pc:= cs.pc(p ; E02);
	used for : s, ls;

;;	%1 = load i32* %0, align 4, !tbaa !3
	proc133 :
	⊦ COP(p, proc133)(cs, cs') ↔ cs .pc(p) = E02 ∧ cs' = cs .pc:= cs.pc(p ; E03) .v1:= cs.v1(p ; cs.mem[cs .v0(p) .v] .v);
	used for : s, ls;

;;	%and = and i32 %1, 1
	NEEDS ATTENTION !
	proc134 :
	⊦ COP(p, proc134)(cs, cs') ↔ cs .pc(p) = E03 ∧ cs' = cs .pc:= cs.pc(p ; E04);
	used for : s, ls;

;;	%tobool = icmp eq i32 %and, 0
	proc135 :
	⊦ COP(p, proc135)(cs, cs') ↔ cs .pc(p) = E04 ∧ (cs .and(p) = 0
	 ⊃ cs' = cs .pc:= cs.pc(p; E05) .tobool:= cs.tobool(p ; 1) ; cs' = cs .pc:= cs.pc(p; E05) .tobool:= cs.tobool(p ; 0));
	used for : s, ls;

;;	br %tobool, label %if.then, label %do.body
	proc136 :
	⊦ COP(p, proc136)(cs, cs') ↔ cs .pc(p) = E05 ∧ cs' = cs .pc:= cs.pc(p ; E06) ∧ cs .tobool(p) = 1;
	used for : s, ls;

;;	br %tobool, label %if.then, label %do.body
	proc137 :
	⊦ COP(p, proc137)(cs, cs') ↔ cs .pc(p) = E05 ∧ cs' = cs .pc:= cs.pc(p ; E02) ∧ cs .tobool(p) = 0;
	used for : s, ls;

;;	%add = add i32 %1, 1
	proc138 :
	⊦ COP(p, proc138)(cs, cs') ↔ cs .pc(p) = E06 ∧ cs' = cs .pc:= cs.pc(p ; E07) .add:= cs.add(p ; cs .v1(p) + 1);
	used for : s, ls;

;;	%2 = cmpxchg i32* %0, i32 %1, i32 %add seq_cst
	proc139 :
	⊦ COP(p, proc139)(cs, cs') ↔ cs .pc(p) = E07 ∧ ( cs.mem[cs .v0(p) .v] = ⌜ cs .v1(p)⌝ ⊃ (cs' = cs .pc:= cs.pc(p; E08) .v2:= cs.v2(p ; ⌜1⌝) .mem:= cs.mem[cs .v0(p) .v, ⌜ cs .add(p)⌝]) ; (cs' = cs .pc:= cs.pc(p; E08) .v2:= cs.v2(p ; ⌜0⌝)));
	used for : s, ls;

;;	%3 = icmp eq i32 %2, %1
	proc1310 :
	⊦ COP(p, proc1310)(cs, cs') ↔ cs .pc(p) = E08 ∧ (cs .v2(p) = ⌜cs .v1(p)⌝ ⊃ cs' = cs .pc:= cs.pc(p; E09) .v3:= cs.v3(p ; 1) ; cs' = cs .pc:= cs.pc(p; E09) .v3:= cs.v3(p ; 0));
	used for : s, ls;

;;	br %3, label %if.end4, label %return
	proc1311 :
	⊦ COP(p, proc1311)(cs, cs') ↔ cs .pc(p) = E09 ∧ cs' = cs .pc:= cs.pc(p ; E10) ∧ cs .v3(p) = 1;
	used for : s, ls;

;;	br %3, label %if.end4, label %return
	proc1312 :
	⊦ COP(p, proc1312)(cs, cs') ↔ cs .pc(p) = E09 ∧ cs' = cs .pc:= cs.pc(p ; E21) .retval_0:= cs.retval_0(p ; (0 - 1)) ∧ cs .v3(p) = 0;
	used for : s, ls;

;;	%4 = load i32** @x, align 4, !tbaa !0
	proc1313 :
	⊦ COP(p, proc1313)(cs, cs') ↔ cs .pc(p) = E10 ∧ cs' = cs .pc:= cs.pc(p ; E11) .v4:= cs.v4(p ; cs.mem[cs .x .v]);
	used for : s, ls;

;;	%retval.0 = phi i32 [, %if.then][, %if.end4][, %if.then7]
	proc1314 :
	⊦ COP(p, proc1314)(cs, cs') ↔ cs .pc(p) = E21 ∧ cs' = cs .pc:= cs.pc(p ; E22);
	used for : s, ls;

;;	store i32 1, i32* %4, align 4, !tbaa !3
	proc1315 :
	⊦ COP(p, proc1315)(cs, cs') ↔ cs .pc(p) = E11 ∧ cs' = cs .pc:= cs.pc(p ; E12);
	used for : s, ls;

;;	%and5 = and i32 %add, 1
	NEEDS ATTENTION !
	proc1317 :
	⊦ COP(p, proc1317)(cs, cs') ↔ cs .pc(p) = E12 ∧ cs' = cs .pc:= cs.pc(p ; E13);
	used for : s, ls;

;;	%tobool6 = icmp eq i32 %and5, 0
	proc1318 :
	⊦ COP(p, proc1318)(cs, cs') ↔ cs .pc(p) = E13 ∧ (cs .and5(p) = 0
	 ⊃ cs' = cs .pc:= cs.pc(p; E14) .tobool6:= cs.tobool6(p ; 1) ; cs' = cs .pc:= cs.pc(p; E14) .tobool6:= cs.tobool6(p ; 0));
	used for : s, ls;

;;	br %tobool6, label %return, label %if.then7
	proc1319 :
	⊦ COP(p, proc1319)(cs, cs') ↔ cs .pc(p) = E14 ∧ cs' = cs .pc:= cs.pc(p ; E21) .retval_0:= cs.retval_0(p ; 1) ∧ cs .tobool6(p) = 1;
	used for : s, ls;

;;	br %tobool6, label %return, label %if.then7
	proc1320 :
	⊦ COP(p, proc1320)(cs, cs') ↔ cs .pc(p) = E14 ∧ cs' = cs .pc:= cs.pc(p ; E15) ∧ cs .tobool6(p) = 0;
	used for : s, ls;

;;	fence seq_cst
	proc1321 :
	⊦ COP(p, proc1321)(cs, cs') ↔ cs .pc(p) = E15 ∧ cs' = cs .pc:= cs.pc(p ; E16);
	used for : s, ls;

;;	%5 = load i32** @glb, align 4, !tbaa !0
	proc1322 :
	⊦ COP(p, proc1322)(cs, cs') ↔ cs .pc(p) = E16 ∧ cs' = cs .pc:= cs.pc(p ; E17) .v5:= cs.v5(p ; cs.mem[cs .glb .v]);
	used for : s, ls;

;;	%6 = load i32* %5, align 4, !tbaa !3
	proc1323 :
	⊦ COP(p, proc1323)(cs, cs') ↔ cs .pc(p) = E17 ∧ cs' = cs .pc:= cs.pc(p ; E18) .v6:= cs.v6(p ; cs.mem[cs .v5(p) .v] .v);
	used for : s, ls;

;;	%inc8 = add i32 %6, 1
	proc1324 :
	⊦ COP(p, proc1324)(cs, cs') ↔ cs .pc(p) = E18 ∧ cs' = cs .pc:= cs.pc(p ; E19) .inc8:= cs.inc8(p ; cs .v6(p) + 1);
	used for : s, ls;

;;	store i32 %inc8, i32* %5, align 4, !tbaa !3
	proc1325 :
	⊦ COP(p, proc1325)(cs, cs') ↔ cs .pc(p) = E19 ∧ cs' = cs .pc:= cs.pc(p ; E20);
	used for : s, ls;

;;	br label %return
	proc1326 :
	⊦ COP(p, proc1326)(cs, cs') ↔ cs .pc(p) = E20 ∧ cs' = cs .pc:= cs.pc(p ; E21) .retval_0:= cs.retval_0(p ; 1);
	used for : s, ls;

;;	%0 = load i32** @glb, align 4, !tbaa !0
	proc231 :
	⊦ COP(p, proc231)(cs, cs') ↔ cs .pc(p) = F00 ∧ cs' = cs .pc:= cs.pc(p ; F01) .v0:= cs.v0(p ; cs.mem[cs .glb .v]);
	used for : s, ls;

;;	br label %do.body
	proc232 :
	⊦ COP(p, proc232)(cs, cs') ↔ cs .pc(p) = F01 ∧ cs' = cs .pc:= cs.pc(p ; F02);
	used for : s, ls;

;;	%1 = load i32* %0, align 4, !tbaa !3
	proc233 :
	⊦ COP(p, proc233)(cs, cs') ↔ cs .pc(p) = F02 ∧ cs' = cs .pc:= cs.pc(p ; F03) .v1:= cs.v1(p ; cs.mem[cs .v0(p) .v] .v);
	used for : s, ls;

;;	%and = and i32 %1, 1
	NEEDS ATTENTION !
	proc234 :
	⊦ COP(p, proc234)(cs, cs') ↔ cs .pc(p) = F03 ∧ cs' = cs .pc:= cs.pc(p ; F04);
	used for : s, ls;

;;	%tobool = icmp eq i32 %and, 0
	proc235 :
	⊦ COP(p, proc235)(cs, cs') ↔ cs .pc(p) = F04 ∧ (cs .and(p) = 0
	 ⊃ cs' = cs .pc:= cs.pc(p; F05) .tobool:= cs.tobool(p ; 1) ; cs' = cs .pc:= cs.pc(p; F05) .tobool:= cs.tobool(p ; 0));
	used for : s, ls;

;;	br %tobool, label %if.then, label %do.body
	proc236 :
	⊦ COP(p, proc236)(cs, cs') ↔ cs .pc(p) = F05 ∧ cs' = cs .pc:= cs.pc(p ; F06) ∧ cs .tobool(p) = 1;
	used for : s, ls;

;;	br %tobool, label %if.then, label %do.body
	proc237 :
	⊦ COP(p, proc237)(cs, cs') ↔ cs .pc(p) = F05 ∧ cs' = cs .pc:= cs.pc(p ; F02) ∧ cs .tobool(p) = 0;
	used for : s, ls;

;;	%add = add i32 %1, 1
	proc238 :
	⊦ COP(p, proc238)(cs, cs') ↔ cs .pc(p) = F06 ∧ cs' = cs .pc:= cs.pc(p ; F07) .add:= cs.add(p ; cs .v1(p) + 1);
	used for : s, ls;

;;	%2 = cmpxchg i32* %0, i32 %1, i32 %add seq_cst
	proc239 :
	⊦ COP(p, proc239)(cs, cs') ↔ cs .pc(p) = F07 ∧ ( cs.mem[cs .v0(p) .v] = ⌜ cs .v1(p)⌝ ⊃ (cs' = cs .pc:= cs.pc(p; F08) .v2:= cs.v2(p ; ⌜1⌝) .mem:= cs.mem[cs .v0(p) .v, ⌜ cs .add(p)⌝]) ; (cs' = cs .pc:= cs.pc(p; F08) .v2:= cs.v2(p ; ⌜0⌝)));
	used for : s, ls;

;;	%3 = icmp eq i32 %2, %1
	proc2310 :
	⊦ COP(p, proc2310)(cs, cs') ↔ cs .pc(p) = F08 ∧ (cs .v2(p) = ⌜cs .v1(p)⌝ ⊃ cs' = cs .pc:= cs.pc(p; F09) .v3:= cs.v3(p ; 1) ; cs' = cs .pc:= cs.pc(p; F09) .v3:= cs.v3(p ; 0));
	used for : s, ls;

;;	br %3, label %if.end4, label %return
	proc2311 :
	⊦ COP(p, proc2311)(cs, cs') ↔ cs .pc(p) = F09 ∧ cs' = cs .pc:= cs.pc(p ; F10) ∧ cs .v3(p) = 1;
	used for : s, ls;

;;	br %3, label %if.end4, label %return
	proc2312 :
	⊦ COP(p, proc2312)(cs, cs') ↔ cs .pc(p) = F09 ∧ cs' = cs .pc:= cs.pc(p ; F21) .retval_0:= cs.retval_0(p ; (0 - 1)) ∧ cs .v3(p) = 0;
	used for : s, ls;

;;	%4 = load i32** @y, align 4, !tbaa !0
	proc2313 :
	⊦ COP(p, proc2313)(cs, cs') ↔ cs .pc(p) = F10 ∧ cs' = cs .pc:= cs.pc(p ; F11) .v4:= cs.v4(p ; cs.mem[cs .y .v]);
	used for : s, ls;

;;	%retval.0 = phi i32 [, %if.then][, %if.end4][, %if.then7]
	proc2314 :
	⊦ COP(p, proc2314)(cs, cs') ↔ cs .pc(p) = F21 ∧ cs' = cs .pc:= cs.pc(p ; F22);
	used for : s, ls;

;;	store i32 1, i32* %4, align 4, !tbaa !3
	proc2315 :
	⊦ COP(p, proc2315)(cs, cs') ↔ cs .pc(p) = F11 ∧ cs' = cs .pc:= cs.pc(p ; F12);
	used for : s, ls;

;;	%and5 = and i32 %add, 1
	NEEDS ATTENTION !
	proc2317 :
	⊦ COP(p, proc2317)(cs, cs') ↔ cs .pc(p) = F12 ∧ cs' = cs .pc:= cs.pc(p ; F13);
	used for : s, ls;

;;	%tobool6 = icmp eq i32 %and5, 0
	proc2318 :
	⊦ COP(p, proc2318)(cs, cs') ↔ cs .pc(p) = F13 ∧ (cs .and5(p) = 0
	 ⊃ cs' = cs .pc:= cs.pc(p; F14) .tobool6:= cs.tobool6(p ; 1) ; cs' = cs .pc:= cs.pc(p; F14) .tobool6:= cs.tobool6(p ; 0));
	used for : s, ls;

;;	br %tobool6, label %return, label %if.then7
	proc2319 :
	⊦ COP(p, proc2319)(cs, cs') ↔ cs .pc(p) = F14 ∧ cs' = cs .pc:= cs.pc(p ; F21) .retval_0:= cs.retval_0(p ; 1) ∧ cs .tobool6(p) = 1;
	used for : s, ls;

;;	br %tobool6, label %return, label %if.then7
	proc2320 :
	⊦ COP(p, proc2320)(cs, cs') ↔ cs .pc(p) = F14 ∧ cs' = cs .pc:= cs.pc(p ; F15) ∧ cs .tobool6(p) = 0;
	used for : s, ls;

;;	fence seq_cst
	proc2321 :
	⊦ COP(p, proc2321)(cs, cs') ↔ cs .pc(p) = F15 ∧ cs' = cs .pc:= cs.pc(p ; F16);
	used for : s, ls;

;;	%5 = load i32** @glb, align 4, !tbaa !0
	proc2322 :
	⊦ COP(p, proc2322)(cs, cs') ↔ cs .pc(p) = F16 ∧ cs' = cs .pc:= cs.pc(p ; F17) .v5:= cs.v5(p ; cs.mem[cs .glb .v]);
	used for : s, ls;

;;	%6 = load i32* %5, align 4, !tbaa !3
	proc2323 :
	⊦ COP(p, proc2323)(cs, cs') ↔ cs .pc(p) = F17 ∧ cs' = cs .pc:= cs.pc(p ; F18) .v6:= cs.v6(p ; cs.mem[cs .v5(p) .v] .v);
	used for : s, ls;

;;	%inc8 = add i32 %6, 1
	proc2324 :
	⊦ COP(p, proc2324)(cs, cs') ↔ cs .pc(p) = F18 ∧ cs' = cs .pc:= cs.pc(p ; F19) .inc8:= cs.inc8(p ; cs .v6(p) + 1);
	used for : s, ls;

;;	store i32 %inc8, i32* %5, align 4, !tbaa !3
	proc2325 :
	⊦ COP(p, proc2325)(cs, cs') ↔ cs .pc(p) = F19 ∧ cs' = cs .pc:= cs.pc(p ; F20);
	used for : s, ls;

;;	br label %return
	proc2326 :
	⊦ COP(p, proc2326)(cs, cs') ↔ cs .pc(p) = F20 ∧ cs' = cs .pc:= cs.pc(p ; F21) .retval_0:= cs.retval_0(p ; 1);
	used for : s, ls;

;;	%0 = load i32** @glb, align 4, !tbaa !0
	proc331 :
	⊦ COP(p, proc331)(cs, cs') ↔ cs .pc(p) = G00 ∧ cs' = cs .pc:= cs.pc(p ; G01) .v0:= cs.v0(p ; cs.mem[cs .glb .v]);
	used for : s, ls;

;;	br label %do.body
	proc332 :
	⊦ COP(p, proc332)(cs, cs') ↔ cs .pc(p) = G01 ∧ cs' = cs .pc:= cs.pc(p ; G02);
	used for : s, ls;

;;	%1 = load i32* %0, align 4, !tbaa !3
	proc333 :
	⊦ COP(p, proc333)(cs, cs') ↔ cs .pc(p) = G02 ∧ cs' = cs .pc:= cs.pc(p ; G03) .v1:= cs.v1(p ; cs.mem[cs .v0(p) .v] .v);
	used for : s, ls;

;;	%and = and i32 %1, 1
	NEEDS ATTENTION !
	proc334 :
	⊦ COP(p, proc334)(cs, cs') ↔ cs .pc(p) = G03 ∧ cs' = cs .pc:= cs.pc(p ; G04);
	used for : s, ls;

;;	%tobool = icmp eq i32 %and, 0
	proc335 :
	⊦ COP(p, proc335)(cs, cs') ↔ cs .pc(p) = G04 ∧ (cs .and(p) = 0
	 ⊃ cs' = cs .pc:= cs.pc(p; G05) .tobool:= cs.tobool(p ; 1) ; cs' = cs .pc:= cs.pc(p; G05) .tobool:= cs.tobool(p ; 0));
	used for : s, ls;

;;	br %tobool, label %do.end, label %do.body
	proc336 :
	⊦ COP(p, proc336)(cs, cs') ↔ cs .pc(p) = G05 ∧ cs' = cs .pc:= cs.pc(p ; G06) ∧ cs .tobool(p) = 1;
	used for : s, ls;

;;	br %tobool, label %do.end, label %do.body
	proc337 :
	⊦ COP(p, proc337)(cs, cs') ↔ cs .pc(p) = G05 ∧ cs' = cs .pc:= cs.pc(p ; G02) ∧ cs .tobool(p) = 0;
	used for : s, ls;

;;	%2 = load i32** @x, align 4, !tbaa !0
	proc338 :
	⊦ COP(p, proc338)(cs, cs') ↔ cs .pc(p) = G06 ∧ cs' = cs .pc:= cs.pc(p ; G07) .v2:= cs.v2(p ; cs.mem[cs .x .v]);
	used for : s, ls;

;;	%3 = load i32* %2, align 4, !tbaa !3
	proc339 :
	⊦ COP(p, proc339)(cs, cs') ↔ cs .pc(p) = G07 ∧ cs' = cs .pc:= cs.pc(p ; G08) .v3:= cs.v3(p ; cs.mem[cs .v2(p) .v] .v);
	used for : s, ls;

;;	%4 = load i32* %0, align 4, !tbaa !3
	proc3310 :
	⊦ COP(p, proc3310)(cs, cs') ↔ cs .pc(p) = G08 ∧ cs' = cs .pc:= cs.pc(p ; G09) .v4:= cs.v4(p ; cs.mem[cs .v0(p) .v]);
	used for : s, ls;

;;	%cmp = icmp eq i32 %4, %1
	proc3311 :
	⊦ COP(p, proc3311)(cs, cs') ↔ cs .pc(p) = G09 ∧ (cs .v4(p) = ⌜cs .v1(p)⌝ ⊃ cs' = cs .pc:= cs.pc(p; G10) .cmp:= cs.cmp(p ; 1) ; cs' = cs .pc:= cs.pc(p; G10) .cmp:= cs.cmp(p ; 0));
	used for : s, ls;

;;	br %cmp, label %if.end, label %return
	proc3312 :
	⊦ COP(p, proc3312)(cs, cs') ↔ cs .pc(p) = G10 ∧ cs' = cs .pc:= cs.pc(p ; G11) ∧ cs .cmp(p) = 1;
	used for : s, ls;

;;	br %cmp, label %if.end, label %return
	proc3313 :
	⊦ COP(p, proc3313)(cs, cs') ↔ cs .pc(p) = G10 ∧ cs' = cs .pc:= cs.pc(p ; G20) .retval_0:= cs.retval_0(p ; (0 - 1)) ∧ cs .cmp(p) = 0;
	used for : s, ls;

;;	store i32 %3, i32* @lx1, align 4, !tbaa !3
	proc3314 :
	⊦ COP(p, proc3314)(cs, cs') ↔ cs .pc(p) = G11 ∧ cs' = cs .pc:= cs.pc(p ; G12);
	used for : s, ls;

;;	%retval.0 = phi i32 [, %do.end][, %if.end][, %if.end3]
	proc3315 :
	⊦ COP(p, proc3315)(cs, cs') ↔ cs .pc(p) = G20 ∧ cs' = cs .pc:= cs.pc(p ; G21);
	used for : s, ls;

;;	%5 = load i32** @y, align 4, !tbaa !0
	proc3316 :
	⊦ COP(p, proc3316)(cs, cs') ↔ cs .pc(p) = G12 ∧ cs' = cs .pc:= cs.pc(p ; G13) .v5:= cs.v5(p ; cs.mem[cs .y .v]);
	used for : s, ls;

;;	%6 = load i32* %5, align 4, !tbaa !3
	proc3318 :
	⊦ COP(p, proc3318)(cs, cs') ↔ cs .pc(p) = G13 ∧ cs' = cs .pc:= cs.pc(p ; G14) .v6:= cs.v6(p ; cs.mem[cs .v5(p) .v] .v);
	used for : s, ls;

;;	%7 = load i32** @glb, align 4, !tbaa !0
	proc3319 :
	⊦ COP(p, proc3319)(cs, cs') ↔ cs .pc(p) = G14 ∧ cs' = cs .pc:= cs.pc(p ; G15) .v7:= cs.v7(p ; cs.mem[cs .glb .v]);
	used for : s, ls;

;;	%8 = load i32* %7, align 4, !tbaa !3
	proc3320 :
	⊦ COP(p, proc3320)(cs, cs') ↔ cs .pc(p) = G15 ∧ cs' = cs .pc:= cs.pc(p ; G16) .v8:= cs.v8(p ; cs.mem[cs .v7(p) .v] .v);
	used for : s, ls;

;;	%cmp1 = icmp eq i32 %8, %1
	proc3321 :
	⊦ COP(p, proc3321)(cs, cs') ↔ cs .pc(p) = G16 ∧ (cs .v8(p) = cs .v1(p)
	 ⊃ cs' = cs .pc:= cs.pc(p; G17) .cmp1:= cs.cmp1(p ; 1) ; cs' = cs .pc:= cs.pc(p; G17) .cmp1:= cs.cmp1(p ; 0));
	used for : s, ls;

;;	br %cmp1, label %if.end3, label %return
	proc3322 :
	⊦ COP(p, proc3322)(cs, cs') ↔ cs .pc(p) = G17 ∧ cs' = cs .pc:= cs.pc(p ; G18) ∧ cs .cmp1(p) = 1;
	used for : s, ls;

;;	br %cmp1, label %if.end3, label %return
	proc3323 :
	⊦ COP(p, proc3323)(cs, cs') ↔ cs .pc(p) = G17 ∧ cs' = cs .pc:= cs.pc(p ; G20) .retval_0:= cs.retval_0(p ; (0 - 1)) ∧ cs .cmp1(p) = 0;
	used for : s, ls;

;;	store i32 %6, i32* @ly1, align 4, !tbaa !3
	proc3324 :
	⊦ COP(p, proc3324)(cs, cs') ↔ cs .pc(p) = G18 ∧ cs' = cs .pc:= cs.pc(p ; G19);
	used for : s, ls;

;;	br label %return
	proc3325 :
	⊦ COP(p, proc3325)(cs, cs') ↔ cs .pc(p) = G19 ∧ cs' = cs .pc:= cs.pc(p ; G20) .retval_0:= cs.retval_0(p ; 1);
	used for : s, ls;

;;	%0 = load i32** @glb, align 4, !tbaa !0
	proc431 :
	⊦ COP(p, proc431)(cs, cs') ↔ cs .pc(p) = H00 ∧ cs' = cs .pc:= cs.pc(p ; H01) .v0:= cs.v0(p ; cs.mem[cs .glb .v]);
	used for : s, ls;

;;	br label %do.body
	proc432 :
	⊦ COP(p, proc432)(cs, cs') ↔ cs .pc(p) = H01 ∧ cs' = cs .pc:= cs.pc(p ; H02);
	used for : s, ls;

;;	%1 = load i32* %0, align 4, !tbaa !3
	proc433 :
	⊦ COP(p, proc433)(cs, cs') ↔ cs .pc(p) = H02 ∧ cs' = cs .pc:= cs.pc(p ; H03) .v1:= cs.v1(p ; cs.mem[cs .v0(p) .v] .v);
	used for : s, ls;

;;	%and = and i32 %1, 1
	NEEDS ATTENTION !
	proc434 :
	⊦ COP(p, proc434)(cs, cs') ↔ cs .pc(p) = H03 ∧ cs' = cs .pc:= cs.pc(p ; H04);
	used for : s, ls;

;;	%tobool = icmp eq i32 %and, 0
	proc435 :
	⊦ COP(p, proc435)(cs, cs') ↔ cs .pc(p) = H04 ∧ (cs .and(p) = 0
	 ⊃ cs' = cs .pc:= cs.pc(p; H05) .tobool:= cs.tobool(p ; 1) ; cs' = cs .pc:= cs.pc(p; H05) .tobool:= cs.tobool(p ; 0));
	used for : s, ls;

;;	br %tobool, label %do.end, label %do.body
	proc436 :
	⊦ COP(p, proc436)(cs, cs') ↔ cs .pc(p) = H05 ∧ cs' = cs .pc:= cs.pc(p ; H06) ∧ cs .tobool(p) = 1;
	used for : s, ls;

;;	br %tobool, label %do.end, label %do.body
	proc437 :
	⊦ COP(p, proc437)(cs, cs') ↔ cs .pc(p) = H05 ∧ cs' = cs .pc:= cs.pc(p ; H02) ∧ cs .tobool(p) = 0;
	used for : s, ls;

;;	%2 = load i32** @y, align 4, !tbaa !0
	proc438 :
	⊦ COP(p, proc438)(cs, cs') ↔ cs .pc(p) = H06 ∧ cs' = cs .pc:= cs.pc(p ; H07) .v2:= cs.v2(p ; cs.mem[cs .y .v]);
	used for : s, ls;

;;	%3 = load i32* %2, align 4, !tbaa !3
	proc439 :
	⊦ COP(p, proc439)(cs, cs') ↔ cs .pc(p) = H07 ∧ cs' = cs .pc:= cs.pc(p ; H08) .v3:= cs.v3(p ; cs.mem[cs .v2(p) .v] .v);
	used for : s, ls;

;;	%4 = load i32* %0, align 4, !tbaa !3
	proc4310 :
	⊦ COP(p, proc4310)(cs, cs') ↔ cs .pc(p) = H08 ∧ cs' = cs .pc:= cs.pc(p ; H09) .v4:= cs.v4(p ; cs.mem[cs .v0(p) .v]);
	used for : s, ls;

;;	%cmp = icmp eq i32 %4, %1
	proc4311 :
	⊦ COP(p, proc4311)(cs, cs') ↔ cs .pc(p) = H09 ∧ (cs .v4(p) = ⌜cs .v1(p)⌝ ⊃ cs' = cs .pc:= cs.pc(p; H10) .cmp:= cs.cmp(p ; 1) ; cs' = cs .pc:= cs.pc(p; H10) .cmp:= cs.cmp(p ; 0));
	used for : s, ls;

;;	br %cmp, label %if.end, label %return
	proc4312 :
	⊦ COP(p, proc4312)(cs, cs') ↔ cs .pc(p) = H10 ∧ cs' = cs .pc:= cs.pc(p ; H11) ∧ cs .cmp(p) = 1;
	used for : s, ls;

;;	br %cmp, label %if.end, label %return
	proc4313 :
	⊦ COP(p, proc4313)(cs, cs') ↔ cs .pc(p) = H10 ∧ cs' = cs .pc:= cs.pc(p ; H20) .retval_0:= cs.retval_0(p ; (0 - 1)) ∧ cs .cmp(p) = 0;
	used for : s, ls;

;;	store i32 %3, i32* @ly2, align 4, !tbaa !3
	proc4314 :
	⊦ COP(p, proc4314)(cs, cs') ↔ cs .pc(p) = H11 ∧ cs' = cs .pc:= cs.pc(p ; H12);
	used for : s, ls;

;;	%retval.0 = phi i32 [, %do.end][, %if.end][, %if.end3]
	proc4315 :
	⊦ COP(p, proc4315)(cs, cs') ↔ cs .pc(p) = H20 ∧ cs' = cs .pc:= cs.pc(p ; H21);
	used for : s, ls;

;;	%5 = load i32** @x, align 4, !tbaa !0
	proc4316 :
	⊦ COP(p, proc4316)(cs, cs') ↔ cs .pc(p) = H12 ∧ cs' = cs .pc:= cs.pc(p ; H13) .v5:= cs.v5(p ; cs.mem[cs .x .v]);
	used for : s, ls;

;;	%6 = load i32* %5, align 4, !tbaa !3
	proc4318 :
	⊦ COP(p, proc4318)(cs, cs') ↔ cs .pc(p) = H13 ∧ cs' = cs .pc:= cs.pc(p ; H14) .v6:= cs.v6(p ; cs.mem[cs .v5(p) .v] .v);
	used for : s, ls;

;;	%7 = load i32** @glb, align 4, !tbaa !0
	proc4319 :
	⊦ COP(p, proc4319)(cs, cs') ↔ cs .pc(p) = H14 ∧ cs' = cs .pc:= cs.pc(p ; H15) .v7:= cs.v7(p ; cs.mem[cs .glb .v]);
	used for : s, ls;

;;	%8 = load i32* %7, align 4, !tbaa !3
	proc4320 :
	⊦ COP(p, proc4320)(cs, cs') ↔ cs .pc(p) = H15 ∧ cs' = cs .pc:= cs.pc(p ; H16) .v8:= cs.v8(p ; cs.mem[cs .v7(p) .v] .v);
	used for : s, ls;

;;	%cmp1 = icmp eq i32 %8, %1
	proc4321 :
	⊦ COP(p, proc4321)(cs, cs') ↔ cs .pc(p) = H16 ∧ (cs .v8(p) = cs .v1(p)
	 ⊃ cs' = cs .pc:= cs.pc(p; H17) .cmp1:= cs.cmp1(p ; 1) ; cs' = cs .pc:= cs.pc(p; H17) .cmp1:= cs.cmp1(p ; 0));
	used for : s, ls;

;;	br %cmp1, label %if.end3, label %return
	proc4322 :
	⊦ COP(p, proc4322)(cs, cs') ↔ cs .pc(p) = H17 ∧ cs' = cs .pc:= cs.pc(p ; H18) ∧ cs .cmp1(p) = 1;
	used for : s, ls;

;;	br %cmp1, label %if.end3, label %return
	proc4323 :
	⊦ COP(p, proc4323)(cs, cs') ↔ cs .pc(p) = H17 ∧ cs' = cs .pc:= cs.pc(p ; H20) .retval_0:= cs.retval_0(p ; (0 - 1)) ∧ cs .cmp1(p) = 0;
	used for : s, ls;

;;	store i32 %6, i32* @lx2, align 4, !tbaa !3
	proc4324 :
	⊦ COP(p, proc4324)(cs, cs') ↔ cs .pc(p) = H18 ∧ cs' = cs .pc:= cs.pc(p ; H19);
	used for : s, ls;

;;	br label %return
	proc4325 :
	⊦ COP(p, proc4325)(cs, cs') ↔ cs .pc(p) = H19 ∧ cs' = cs .pc:= cs.pc(p ; H20) .retval_0:= cs.retval_0(p ; 1);
	used for : s, ls;

;;	ret i32 %retval.0
	proc1116ret :
	⊦ RETOP(p, proc1116ret)(cs, cs', return) ↔ cs .pc(p) = A29 ∧ cs' = cs .pc:= cs.pc(p ; N) ∧ return = cs .retval_0(p);
	used for : s, ls;
	
;;	ret i32 %retval.0
	proc2116ret :
	⊦ RETOP(p, proc2116ret)(cs, cs', return) ↔ cs .pc(p) = B29 ∧ cs' = cs .pc:= cs.pc(p ; N) ∧ return = cs .retval_0(p);
	used for : s, ls;
	
;;	ret i32 %retval.0
	proc1216ret :
	⊦ RETOP(p, proc1216ret)(cs, cs', return) ↔ cs .pc(p) = C36 ∧ cs' = cs .pc:= cs.pc(p ; N) ∧ return = cs .retval_0(p);
	used for : s, ls;
	
;;	ret i32 %retval.0
	proc2216ret :
	⊦ RETOP(p, proc2216ret)(cs, cs', return) ↔ cs .pc(p) = D36 ∧ cs' = cs .pc:= cs.pc(p ; N) ∧ return = cs .retval_0(p);
	used for : s, ls;
	
;;	ret i32 %retval.0
	proc1316ret :
	⊦ RETOP(p, proc1316ret)(cs, cs', return) ↔ cs .pc(p) = E22 ∧ cs' = cs .pc:= cs.pc(p ; N) ∧ return = cs .retval_0(p);
	used for : s, ls;
	
;;	ret i32 %retval.0
	proc2316ret :
	⊦ RETOP(p, proc2316ret)(cs, cs', return) ↔ cs .pc(p) = F22 ∧ cs' = cs .pc:= cs.pc(p ; N) ∧ return = cs .retval_0(p);
	used for : s, ls;
	
;;	ret i32 %retval.0
	proc3317ret :
	⊦ RETOP(p, proc3317ret)(cs, cs', return) ↔ cs .pc(p) = G21 ∧ cs' = cs .pc:= cs.pc(p ; N) ∧ return = cs .retval_0(p);
	used for : s, ls;
	
;;	ret i32 %retval.0
	proc4317ret :
	⊦ RETOP(p, proc4317ret)(cs, cs', return) ↔ cs .pc(p) = H21 ∧ cs' = cs .pc:= cs.pc(p ; N) ∧ return = cs .retval_0(p);
	used for : s, ls;
	
;;	ret i32 0
	main1ret :
	⊦ RETOP(p, main1ret)(cs, cs', return) ↔ cs .pc(p) = I0 ∧ cs' = cs .pc:= cs.pc(p ; N) ∧ return = 0;
	used for : s, ls;
	
end enrich
